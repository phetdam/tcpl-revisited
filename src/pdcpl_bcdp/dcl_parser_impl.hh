/**
 * @file dcl_parser_impl.hh
 * @author Derek Huang
 * @brief C++ parser implementation for simplified C declarations
 * @copyright MIT License
 */

#ifndef PDCPL_BCDP_DCL_PARSER_IMPL_HH_
#define PDCPL_BCDP_DCL_PARSER_IMPL_HH_

#include <string>

#include "pdcpl/warnings.h"

/**
 * Forward declaration to satisfy the `yy::dcl_parser` class definition.
 *
 * The `yy::dcl_parser` takes a `pdcpl::dcl_parser_impl&` as a parameter.
 */
namespace pdcpl { class dcl_parser_impl; }  // namespace pdcpl

/**
 * The C++ header generated by Bison defining the parsing class.
 *
 * We need this in order to use `YY_DECL`, and so this must be included first.
 *
 * MSVC always emits C4065 (switch with default but no case labels) when this
 * header is included in a translation unit, so we disable when including.
 */
PDCPL_MSVC_WARNING_DISABLE(4065)
#include "parser.yy.hh"
PDCPL_MSVC_WARNING_ENABLE()

/**
 * `YY_DECL` function declaration return type.
 *
 * This is defined separately so the `yylex` friend declaration can use it.
 */
#define PDCPL_BCDP_YYLEX_RETURN yy::dcl_parser::symbol_type

/**
 * `YY_DECL` function name.
 *
 * Usually this can be left as `yylex` unless the Flex name prefix is changed.
 */
#define PDCPL_BCDP_YYLEX yylex

/**
 * `YY_DECL` function declaration arguments.
 *
 * Should be a comma-separated list of function arguments.
 */
#define PDCPL_BCDP_YYLEX_ARGS pdcpl::dcl_parser_impl& parser

/**
 * Macro declaring `yylex` in the format the Bison parser expects.
 *
 * The corresponding parser handles complete symbols and uses variant values.
 */
#define YY_DECL PDCPL_BCDP_YYLEX_RETURN PDCPL_BCDP_YYLEX(PDCPL_BCDP_YYLEX_ARGS)

/**
 * `yylex` declaration compatible with C++ Bison parser.
 *
 * There is no need to make this `extern "C"` since the generated Flex lexer
 * is being compiled as C++, not as straight C code.
 */
YY_DECL;

namespace pdcpl {

/**
 * Parser driver implementation class for parsing C declarations.
 */
class dcl_parser_impl {
public:
  /**
   * Parse the specified input file.
   *
   * @param input_file File to read input from, empty or "-" for `stdin`
   * @param trace_lexer `true` to enable lexer tracing
   * @param trace_parser `true` to enable parser tracing
   * @returns `true` on success, `false` on failure
   */
  bool parse(const std::string& input_file, bool trace_lexer, bool trace_parser);

  // allow lexer to access to the parse driver members to update location +
  // error. we use (::PDCPL_BCDP_YYLEX) to tell compiler PDCPL_BCDP_YYLEX is in
  // the global namespace, not in the current enclosing pdcpl namespace
  friend PDCPL_BCDP_YYLEX_RETURN (::PDCPL_BCDP_YYLEX)(PDCPL_BCDP_YYLEX_ARGS);
  // allow parser to access parse driver members to update location + error
  friend class yy::dcl_parser;

  /**
   * Return last location of the parser.
   */
  const auto& location() const noexcept { return location_; }

  /**
   * Return last error encountered during parsing.
   */
  const auto& last_error() const noexcept { return last_error_; }

private:
  yy::location location_;
  std::string last_error_;

  /**
   * Perform setup for the Flex lexer.
   *
   * @param input_file Input file to read. If empty or "-", `stdin` is used.
   * @param enable_debug `true` to turn on lexer tracing, default `false`
   * @returns `true` on success, `false` on failure and sets `last_error_`
   */
  bool lex_setup(const std::string& input_file, bool enable_tracing) noexcept;

  /**
   * Perform cleanup for the Flex lexer.
   *
   * Currently, all this does is close `yyin` unless `yyin` is `stdin`.
   *
   * @param input_file Input file passed to `lex_setup`. Used in error reporting.
   * @returns `true` on success, `false` on failure and sets `last_error_`
   */
  bool lex_cleanup(const std::string& input_file) noexcept;
};

}  // namespace pdcpl

#endif  // PDCPL_BCDP_DCL_PARSER_IMPL_HH_
