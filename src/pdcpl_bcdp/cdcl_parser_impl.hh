/**
 * @file cdcl_parser_impl.hh
 * @author Derek Huang
 * @brief C++ parser implementation for simplified C declarations
 * @copyright MIT License
 */

#ifndef PDCPL_BCDP_CDCL_PARSER_IMPL_HH_
#define PDCPL_BCDP_CDCL_PARSER_IMPL_HH_

#include <filesystem>
#include <string>
#include <unordered_map>
#include <vector>

#include "pdcpl/cdcl_type_spec.hh"
#include "pdcpl/cdcl_dcln_spec.hh"
#include "pdcpl/warnings.h"

// #include "dcl_parser_dcln.hh"

/**
 * Forward declaration to satisfy the `yy::cdcl_parser` class definition.
 *
 * The `yy::cdcl_parser` takes a `pdcpl::cdcl_parser_impl&` as a parameter.
 */
namespace pdcpl { class cdcl_parser_impl; }  // namespace pdcpl

/**
 * The C++ header generated by Bison defining the parsing class.
 *
 * We need this in order to use `YY_DECL`, and so this must be included first.
 *
 * MSVC always emits C4065 (switch with default but no case labels) when this
 * header is included in a translation unit, so we disable when including.
 *
 * Any required headers should be included before this Bison-generated header.
 */
PDCPL_MSVC_WARNING_DISABLE(4065)
#include "parser.yy.hh"
PDCPL_MSVC_WARNING_ENABLE()

/**
 * `YY_DECL` function declaration return type.
 *
 * This is defined separately so the `yylex` friend declaration can use it.
 */
#define PDCPL_BCDP_YYLEX_RETURN yy::cdcl_parser::symbol_type

/**
 * `YY_DECL` function name.
 *
 * Usually this can be left as `yylex` unless the Flex name prefix is changed.
 */
#define PDCPL_BCDP_YYLEX yylex

/**
 * `YY_DECL` function declaration arguments.
 *
 * Should be a comma-separated list of function arguments.
 */
#define PDCPL_BCDP_YYLEX_ARGS pdcpl::cdcl_parser_impl& parser

/**
 * Macro declaring `yylex` in the format the Bison parser expects.
 *
 * The corresponding parser handles complete symbols and uses variant values.
 */
#define YY_DECL PDCPL_BCDP_YYLEX_RETURN PDCPL_BCDP_YYLEX(PDCPL_BCDP_YYLEX_ARGS)

/**
 * `yylex` declaration compatible with C++ Bison parser.
 *
 * There is no need to make this `extern "C"` since the generated Flex lexer
 * is being compiled as C++, not as straight C code.
 */
YY_DECL;

namespace pdcpl {

/**
 * Parser driver implementation class for parsing C declarations.
 */
class cdcl_parser_impl {
public:
  /**
   * Ctor.
   *
   * @param include_text `true` to include text results, which slows parsing.
   */
  cdcl_parser_impl(bool include_text = false) : include_text_{include_text} {}

  /**
   * Parse the specified input file.
   *
   * @param input_file File to read input from, empty or "-" for `stdin`
   * @param trace_lexer `true` to enable lexer tracing
   * @param trace_parser `true` to enable parser tracing
   * @returns `true` on success, `false` on failure
   */
  bool parse(
    const std::filesystem::path& input_file,
    bool trace_lexer,
    bool trace_parser);

  // allow lexer to access to the parse driver members to update location +
  // error. we use (::PDCPL_BCDP_YYLEX) to tell compiler PDCPL_BCDP_YYLEX is in
  // the global namespace, not in the current enclosing pdcpl namespace
  friend PDCPL_BCDP_YYLEX_RETURN (::PDCPL_BCDP_YYLEX)(PDCPL_BCDP_YYLEX_ARGS);
  // allow parser to access parse driver members to update location + error
  friend class yy::cdcl_parser;

  /**
   * Return last location of the parser.
   */
  const auto& location() const noexcept { return location_; }

  /**
   * Return last error encountered during parsing.
   */
  const auto& last_error() const noexcept { return last_error_; }

  /**
   * Return `true` if text results were parsed, `false` otherwise.
   */
  auto include_text() const noexcept { return include_text_; }

  /*
  const auto& results() const noexcept { return results_; }

  auto& results() noexcept { return results_; }

  void insert(const std::vector<dcl_parser_dclr>& dclrs)
  {
    for (const auto& dclr : dclrs)
      insert(dclr);
  }

  void insert(const dcl_parser_dclr& dclr);
  */

private:
  yy::location location_;
  std::string last_error_;
  bool include_text_;
  // std::unordered_map<std::string, dcl_parser_dcln> results_;

  /**
   * Perform setup for the Flex lexer.
   *
   * @param input_file Input file to read. If empty or "-", `stdin` is used.
   * @param enable_debug `true` to turn on lexer tracing, default `false`
   * @returns `true` on success, `false` on failure and sets `last_error_`
   */
  bool lex_setup(const std::string& input_file, bool enable_tracing) noexcept;

  /**
   * Perform cleanup for the Flex lexer.
   *
   * Currently, all this does is close `yyin` unless `yyin` is `stdin`.
   *
   * @param input_file Input file passed to `lex_setup`. Used in error reporting.
   * @returns `true` on success, `false` on failure and sets `last_error_`
   */
  bool lex_cleanup(const std::string& input_file) noexcept;
};

}  // namespace pdcpl

#endif  // PDCPL_BCDP_CDCL_PARSER_IMPL_HH_
